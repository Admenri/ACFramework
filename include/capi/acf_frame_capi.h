// Copyright (c) 2023 Admenri. All rights reserved.
// ---------------------------------------------------------------------------
//
// This file was generated by the ACF translator tool and should not edited
// by hand. See the translator.README.txt file in the tools directory for
// more information.
//
// $hash=ba30b885edfdd1e7b24a6ba96f51647160ef2b82$
//

#ifndef ACF_INCLUDE_CAPI_ACF_FRAME_CAPI_H_
#define ACF_INCLUDE_CAPI_ACF_FRAME_CAPI_H_
#pragma once

#include "include/capi/acf_browser_capi.h"
#include "include/capi/acf_callback_capi.h"
#include "include/capi/acf_values_capi.h"
#include "include/internal/acf_scoped_refptr.h"
#include "include/internal/acf_types.h"

#ifdef __cplusplus
extern "C" {
#endif

struct _acf_browser_t;
struct _acf_complete_value_handler_t;
struct _acf_string_visitor_t;

///
/// Frame object that host a iframe dom in browser webcontents, Any operation is
/// async in thread for multi-process arch.
///
typedef struct _acf_frame_t {
  ///
  /// Base structure.
  ///
  acf_base_ref_counted_t base;

  ///
  /// Get frame object valid state.
  ///
  int(ACF_CALLBACK* is_valid)(struct _acf_frame_t* self);

  ///
  /// Compare object with other object.
  ///
  int(ACF_CALLBACK* is_same)(struct _acf_frame_t* self,
                             struct _acf_frame_t* object);

  ///
  /// Returns the parent of this frame or NULL if this is the main (top-level)
  /// frame.
  ///
  struct _acf_frame_t*(ACF_CALLBACK* get_parent)(struct _acf_frame_t* self);

  ///
  /// Returns the browser that this frame belongs to.
  ///
  struct _acf_browser_t*(ACF_CALLBACK* get_browser)(struct _acf_frame_t* self);

  ///
  /// Returns the URL currently loaded in this frame.
  ///
  // The resulting string must be freed by calling acf_string_userfree_free().
  acf_string_userfree_t(ACF_CALLBACK* get_url)(struct _acf_frame_t* self);

  ///
  /// Returns the name for this frame. If the frame has an assigned name (for
  /// example, set via the iframe "name" attribute) then that value will be
  /// returned. Otherwise a unique name will be constructed based on the frame
  /// parent hierarchy. The main (top-level) frame will always have an NULL name
  /// value.
  ///
  // The resulting string must be freed by calling acf_string_userfree_free().
  acf_string_userfree_t(ACF_CALLBACK* get_name)(struct _acf_frame_t* self);

  ///
  /// Returns the globally unique identifier for this frame or < 0 if the
  /// underlying frame does not yet exist.
  ///
  int64(ACF_CALLBACK* get_identifier)(struct _acf_frame_t* self);

  ///
  /// Is frame main context in browser.
  ///
  int(ACF_CALLBACK* is_main)(struct _acf_frame_t* self);

  ///
  /// Execute javascripts in current frame context. value is invalid when return
  ///
  void(ACF_CALLBACK* execute_javascript)(
      struct _acf_frame_t* self,
      const acf_string_t* script,
      const acf_string_t* url,
      struct _acf_complete_value_handler_t* handler);

  ///
  /// Retrieve this frame's HTML source as a string sent to the specified
  /// visitor.
  ///
  void(ACF_CALLBACK* get_source)(struct _acf_frame_t* self,
                                 struct _acf_string_visitor_t* visitor);

  ///
  /// Retrieve this frame's display text as a string sent to the specified
  /// visitor.
  ///
  void(ACF_CALLBACK* get_text)(struct _acf_frame_t* self,
                               struct _acf_string_visitor_t* visitor);
} acf_frame_t;

#ifdef __cplusplus
}
#endif

#endif  // ACF_INCLUDE_CAPI_ACF_FRAME_CAPI_H_
