// Copyright (c) 2023 Admenri. All rights reserved.
// ---------------------------------------------------------------------------
//
// This file was generated by the ACF translator tool and should not edited
// by hand. See the translator.README.txt file in the tools directory for
// more information.
//
// $hash=cd2a93f02809c68cbd785046d0288d2eeb91549c$
//

#ifndef ACF_INCLUDE_CAPI_ACF_RESOURCE_REQUEST_HANDLER_CAPI_H_
#define ACF_INCLUDE_CAPI_ACF_RESOURCE_REQUEST_HANDLER_CAPI_H_
#pragma once

#include "include/capi/acf_callback_capi.h"
#include "include/capi/acf_frame_capi.h"
#include "include/capi/acf_profile_capi.h"
#include "include/capi/acf_request_capi.h"
#include "include/capi/acf_response_capi.h"
#include "include/internal/acf_scoped_refptr.h"
#include "include/internal/acf_types.h"

#ifdef __cplusplus
extern "C" {
#endif

struct _acf_callback_t;
struct _acf_frame_t;
struct _acf_resource_handler_t;
struct _acf_resource_read_callback_t;
struct _acf_resource_request_handler_t;
struct _acf_resource_skip_callback_t;
struct _acf_response_filter_t;

///
/// Implement this structure to handle events related to browser requests. The
/// functions of this structure will be called on the IO thread unless otherwise
/// indicated.
///
typedef struct _acf_resource_request_handler_t {
  ///
  /// Base structure.
  ///
  acf_base_ref_counted_t base;

  ///
  /// Called on the IO thread before a resource request is loaded. The |browser|
  /// and |frame| values represent the source of the request, and may be NULL
  /// for requests originating from service workers or AcfURLRequest. To
  /// redirect or change the resource load optionally modify |request|.
  /// Modification of the request URL will be treated as a redirect. Return
  /// RV_CONTINUE to continue the request immediately. Default: Continue load
  /// resource.
  ///
  int(ACF_CALLBACK* on_before_resource_load)(
      struct _acf_resource_request_handler_t* self,
      struct _acf_profile_t* profile,
      int64 frame_id,
      struct _acf_request_t* request);

  ///
  /// Called on the IO thread before a resource is loaded. The |browser| and
  /// |frame| values represent the source of the request, and may be NULL for
  /// requests originating from service workers or AcfURLRequest. To allow the
  /// resource to load using the default network loader return NULL. To specify
  /// a handler for the resource return a acf_resource_handler_t object. The
  /// |request| object cannot not be modified in this callback.
  ///
  struct _acf_resource_handler_t*(ACF_CALLBACK* get_resource_handler)(
      struct _acf_resource_request_handler_t* self,
      struct _acf_profile_t* profile,
      int64 frame_id,
      struct _acf_request_t* request);

  ///
  /// Called on the IO thread when a resource load is redirected. The |browser|
  /// and |frame| values represent the source of the request, and may be NULL
  /// for requests originating from service workers or AcfURLRequest. The
  /// |request| parameter will contain the old URL and other request-related
  /// information. The |response| parameter will contain the response that
  /// resulted in the redirect. The |new_url| parameter will contain the new URL
  /// and can be changed if desired. The |request| and |response| objects cannot
  /// be modified in this callback.
  ///
  void(ACF_CALLBACK* on_resource_redirect)(
      struct _acf_resource_request_handler_t* self,
      struct _acf_profile_t* profile,
      int64 frame_id,
      struct _acf_request_t* request,
      struct _acf_response_t* response,
      acf_string_t* new_url);

  ///
  /// Called on the IO thread when a resource response is received. The
  /// |browser| and |frame| values represent the source of the request, and may
  /// be NULL for requests originating from service workers or CefURLRequest. To
  /// allow the resource load to proceed without modification return false (0).
  /// To redirect or retry the resource load optionally modify |request| and
  /// return true (1). Modification of the request URL will be treated as a
  /// redirect. Requests handled using the default network loader cannot be
  /// redirected in this callback. The |response| object cannot be modified in
  /// this callback.
  ///
  /// WARNING: Redirecting using this function is deprecated. Use
  /// OnBeforeResourceLoad or GetResourceHandler to perform redirects.
  ///
  void(ACF_CALLBACK* on_resource_response)(
      struct _acf_resource_request_handler_t* self,
      struct _acf_profile_t* profile,
      int64 frame_id,
      struct _acf_request_t* request,
      struct _acf_response_t* response);

  ///
  /// Called on the IO thread to optionally filter resource response content.
  /// The |browser| and |frame| values represent the source of the request, and
  /// may be NULL for requests originating from service workers or
  /// AcfURLRequest. |request| and |response| represent the request and response
  /// respectively and cannot be modified in this callback.
  ///
  struct _acf_response_filter_t*(ACF_CALLBACK* get_resource_response_filter)(
      struct _acf_resource_request_handler_t* self,
      struct _acf_profile_t* profile,
      int64 frame_id,
      struct _acf_request_t* request,
      struct _acf_response_t* response);

  ///
  /// Called on the IO thread when a resource load has completed. The |browser|
  /// and |frame| values represent the source of the request, and may be NULL
  /// for requests originating from service workers or AcfURLRequest. |request|
  /// and |response| represent the request and response respectively and cannot
  /// be modified in this callback. |status| indicates the load completion
  /// status. |received_content_length| is the number of response bytes actually
  /// read. This function will be called for all requests, including requests
  /// that are aborted due to Acf shutdown or destruction of the associated
  /// browser. In cases where the associated browser is destroyed this callback
  /// may arrive after the AcfLifeSpanHandler::OnBeforeClose callback for that
  /// browser. The acf_frame_t::IsValid function can be used to test for this
  /// situation, and care should be taken not to call |browser| or |frame|
  /// functions that modify state (like LoadURL, SendProcessMessage, etc.) if
  /// the frame is invalid.
  ///
  void(ACF_CALLBACK* on_resource_load_complete)(
      struct _acf_resource_request_handler_t* self,
      struct _acf_profile_t* profile,
      int64 frame_id,
      struct _acf_request_t* request,
      struct _acf_response_t* response,
      acf_urlrequest_status_t status,
      int64 received_content_length);
} acf_resource_request_handler_t;

///
/// Callback for asynchronous continuation of acf_resource_handler_t::skip().
///
typedef struct _acf_resource_skip_callback_t {
  ///
  /// Base structure.
  ///
  acf_base_ref_counted_t base;

  ///
  /// Callback for asynchronous continuation of skip(). If |bytes_skipped| > 0
  /// then either skip() will be called again until the requested number of
  /// bytes have been skipped or the request will proceed. If |bytes_skipped| <=
  /// 0 the request will fail with ERR_REQUEST_RANGE_NOT_SATISFIABLE.
  ///
  void(ACF_CALLBACK* cont)(struct _acf_resource_skip_callback_t* self,
                           int64 bytes_skipped);
} acf_resource_skip_callback_t;

///
/// Callback for asynchronous continuation of acf_resource_handler_t::read().
///
typedef struct _acf_resource_read_callback_t {
  ///
  /// Base structure.
  ///
  acf_base_ref_counted_t base;

  ///
  /// Callback for asynchronous continuation of read(). If |bytes_read| == 0 the
  /// response will be considered complete. If |bytes_read| > 0 then read() will
  /// be called again until the request is complete (based on either the result
  /// or the expected content length). If |bytes_read| < 0 then the request will
  /// fail and the |bytes_read| value will be treated as the error code.
  ///
  void(ACF_CALLBACK* cont)(struct _acf_resource_read_callback_t* self,
                           int bytes_read);
} acf_resource_read_callback_t;

///
/// Structure used to implement a custom request handler structure. The
/// functions of this structure will be called on the IO thread unless otherwise
/// indicated.
///
typedef struct _acf_resource_handler_t {
  ///
  /// Base structure.
  ///
  acf_base_ref_counted_t base;

  ///
  /// Open the response stream. To handle the request immediately set
  /// |handle_request| to true (1) and return true (1). To decide at a later
  /// time set |handle_request| to false (0), return true (1), and execute
  /// |callback| to continue or cancel the request. To cancel the request
  /// immediately set |handle_request| to true (1) and return false (0). This
  /// function will be called in sequence but not from a dedicated thread. For
  /// backwards compatibility set |handle_request| to false (0) and return false
  /// (0) and the ProcessRequest function will be called.
  ///
  int(ACF_CALLBACK* open)(struct _acf_resource_handler_t* self,
                          struct _acf_request_t* request,
                          int* handle_request);

  ///
  /// Retrieve response header information. If the response length is not known
  /// set |response_length| to -1 and ReadResponse() will be called until it
  /// returns false (0). If the response length is known set |response_length|
  /// to a positive value and ReadResponse() will be called until it returns
  /// false (0) or the specified number of bytes have been read. Use the
  /// |response| object to set the mime type, http status code and other
  /// optional header values. To redirect the request to a new URL set
  /// |redirectUrl| to the new URL. |redirectUrl| can be either a relative or
  /// fully qualified URL. It is also possible to set |response| to a redirect
  /// http status code and pass the new URL via a Location header. Likewise with
  /// |redirectUrl| it is valid to set a relative or fully qualified URL as the
  /// Location header value. If an error occured while setting up the request
  /// you can call set_error() on |response| to indicate the error condition.
  ///
  void(ACF_CALLBACK* get_response_headers)(struct _acf_resource_handler_t* self,
                                           struct _acf_response_t* response,
                                           int64* response_length,
                                           acf_string_t* redirectUrl);

  ///
  /// Skip response data when requested by a Range header. Skip over and discard
  /// |bytes_to_skip| bytes of response data. If data is available immediately
  /// set |bytes_skipped| to the number of bytes skipped and return true (1). To
  /// read the data at a later time set |bytes_skipped| to 0, return true (1)
  /// and execute |callback| when the data is available. To indicate failure set
  /// |bytes_skipped| to < 0 (e.g. -2 for ERR_FAILED) and return false (0). This
  /// function will be called in sequence but not from a dedicated thread.
  ///
  void(ACF_CALLBACK* skip)(struct _acf_resource_handler_t* self,
                           int64 bytes_to_skip,
                           struct _acf_resource_skip_callback_t* callback);

  ///
  /// Read response data. If data is available immediately copy up to
  /// |bytes_to_read| bytes into |data_out|, set |bytes_read| to the number of
  /// bytes copied, and return true (1). To read the data at a later time keep a
  /// pointer to |data_out|, set |bytes_read| to 0, return true (1) and execute
  /// |callback| when the data is available (|data_out| will remain valid until
  /// the callback is executed). To indicate response completion set
  /// |bytes_read| to 0 and return false (0). To indicate failure set
  /// |bytes_read| to < 0 (e.g. -2 for ERR_FAILED) and return false (0). This
  /// function will be called in sequence but not from a dedicated thread. For
  /// backwards compatibility set |bytes_read| to -1 and return false (0) and
  /// the ReadResponse function will be called.
  ///
  void(ACF_CALLBACK* read)(struct _acf_resource_handler_t* self,
                           void* data_out,
                           int bytes_to_read,
                           struct _acf_resource_read_callback_t* callback);

  ///
  /// Request processing has been canceled.
  ///
  void(ACF_CALLBACK* cancel)(struct _acf_resource_handler_t* self);
} acf_resource_handler_t;

///
/// Implement this structure to filter resource response content. The functions
/// of this structure will be called on the browser process IO thread.
///
typedef struct _acf_response_filter_t {
  ///
  /// Base structure.
  ///
  acf_base_ref_counted_t base;

  ///
  /// Initialize the response filter. Will only be called a single time. The
  /// filter will not be installed if this function returns false (0).
  ///
  int(ACF_CALLBACK* init_filter)(struct _acf_response_filter_t* self);

  ///
  /// Called to filter a chunk of data. Expected usage is as follows:
  ///
  ///  1. Read input data from |data_in| and set |data_in_read| to the number of
  ///     bytes that were read up to a maximum of |data_in_size|. |data_in| will
  ///     be NULL if |data_in_size| is zero.
  ///  2. Write filtered output data to |data_out| and set |data_out_written| to
  ///     the number of bytes that were written up to a maximum of
  ///     |data_out_size|. If no output data was written then all data must be
  ///     read from |data_in| (user must set |data_in_read| = |data_in_size|).
  ///  3. Return RESPONSE_FILTER_DONE if all output data was written or
  ///     RESPONSE_FILTER_NEED_MORE_DATA if output data is still pending.
  ///
  /// This function will be called repeatedly until the input buffer has been
  /// fully read (user sets |data_in_read| = |data_in_size|) and there is no
  /// more input data to filter (the resource response is complete). This
  /// function may then be called an additional time with an NULL input buffer
  /// if the user filled the output buffer (set |data_out_written| =
  /// |data_out_size|) and returned RESPONSE_FILTER_NEED_MORE_DATA to indicate
  /// that output data is still pending.
  ///
  /// Calls to this function will stop when one of the following conditions is
  /// met:
  ///
  ///  1. There is no more input data to filter (the resource response is
  ///     complete) and the user sets |data_out_written| = 0 or returns
  ///     RESPONSE_FILTER_DONE to indicate that all data has been written, or;
  ///  2. The user returns RESPONSE_FILTER_ERROR to indicate an error.
  ///
  /// Do not keep a reference to the buffers passed to this function.
  ///
  acf_response_filter_status_t(ACF_CALLBACK* filter)(
      struct _acf_response_filter_t* self,
      void* data_in,
      size_t data_in_size,
      size_t* data_in_read,
      void* data_out,
      size_t data_out_size,
      size_t* data_out_written);
} acf_response_filter_t;

#ifdef __cplusplus
}
#endif

#endif  // ACF_INCLUDE_CAPI_ACF_RESOURCE_REQUEST_HANDLER_CAPI_H_
