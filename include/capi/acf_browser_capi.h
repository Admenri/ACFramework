// Copyright (c) 2023 Admenri. All rights reserved.
// ---------------------------------------------------------------------------
//
// This file was generated by the ACF translator tool and should not edited
// by hand. See the translator.README.txt file in the tools directory for
// more information.
//
// $hash=2fc3f01a533a5c7e43defea9ff2b156f5ee49aaf$
//

#ifndef ACF_INCLUDE_CAPI_ACF_BROWSER_CAPI_H_
#define ACF_INCLUDE_CAPI_ACF_BROWSER_CAPI_H_
#pragma once

#include "include/capi/acf_browser_handler_capi.h"
#include "include/capi/acf_context_menu_capi.h"
#include "include/capi/acf_environment_capi.h"
#include "include/capi/acf_frame_capi.h"
#include "include/capi/acf_values_capi.h"
#include "include/internal/acf_scoped_refptr.h"
#include "include/internal/acf_string.h"
#include "include/internal/acf_string_list.h"
#include "include/internal/acf_types.h"
#include "include/internal/acf_types_wrappers.h"

#ifdef __cplusplus
extern "C" {
#endif

struct _acf_browser_t;
struct _acf_context_menu_callback_t;
struct _acf_dictionary_value_t;
struct _acf_environment_t;
struct _acf_frame_t;
struct _acf_login_delegate_t;
struct _acf_new_window_delegate_t;
struct _acf_profile_t;

///
/// ACF's browser object host, in fact a browser was a window in chromium with
/// tabs control.
///
typedef struct _acf_browser_t {
  ///
  /// Base structure.
  ///
  acf_base_ref_counted_t base;

  ///
  /// Is same object
  ///
  int(ACF_CALLBACK* is_same)(struct _acf_browser_t* self,
                             struct _acf_browser_t* that);

  ///
  /// Get browser event handler
  ///
  struct _acf_browser_handler_t*(ACF_CALLBACK* get_handler)(
      struct _acf_browser_t* self);

  ///
  /// Get browser create's sign.
  ///
  struct _acf_dictionary_value_t*(ACF_CALLBACK* get_extra_info)(
      struct _acf_browser_t* self);

  ///
  /// Get parent environment
  ///
  struct _acf_environment_t*(ACF_CALLBACK* get_environment)(
      struct _acf_browser_t* self);

  ///
  /// Close browser, it will call browser close event (or unlaod dialog)
  ///
  void(ACF_CALLBACK* close)(struct _acf_browser_t* self, int force);

  ///
  /// Get browser window handle
  ///
  acf_window_handle_t(ACF_CALLBACK* get_window_handle)(
      struct _acf_browser_t* self);

  ///
  /// Get delegate status
  ///
  int(ACF_CALLBACK* is_valid)(struct _acf_browser_t* self);

  ///
  /// Browser navigation entry controller: can go back
  ///
  int(ACF_CALLBACK* can_go_back)(struct _acf_browser_t* self);

  ///
  /// Browser navigation entry controller: can go forward
  ///
  int(ACF_CALLBACK* can_go_forward)(struct _acf_browser_t* self);

  ///
  /// Browser navigation entry controller: go back
  ///
  void(ACF_CALLBACK* go_back)(struct _acf_browser_t* self);

  ///
  /// Browser navigation entry controller: go forward
  ///
  void(ACF_CALLBACK* go_forward)(struct _acf_browser_t* self);

  ///
  /// Browser navigation entry controller: reload
  ///
  void(ACF_CALLBACK* reload)(struct _acf_browser_t* self, int ignore_cache);

  ///
  /// Browser navigation entry controller: stop loading
  ///
  void(ACF_CALLBACK* stop)(struct _acf_browser_t* self);

  ///
  /// Browser navigation entry controller: loading
  ///
  int(ACF_CALLBACK* is_loading)(struct _acf_browser_t* self);

  ///
  /// Navigate to target url (Main frame)
  ///
  void(ACF_CALLBACK* load_url)(struct _acf_browser_t* self,
                               const acf_string_t* url);

  ///
  /// Get current url
  ///
  // The resulting string must be freed by calling acf_string_userfree_free().
  acf_string_userfree_t(ACF_CALLBACK* get_url)(struct _acf_browser_t* self);

  ///
  /// Get title
  ///
  // The resulting string must be freed by calling acf_string_userfree_free().
  acf_string_userfree_t(ACF_CALLBACK* get_title)(struct _acf_browser_t* self);

  ///
  /// Focus to native widget
  ///
  void(ACF_CALLBACK* focus)(struct _acf_browser_t* self);

  ///
  /// Set/Get window visible
  ///
  void(ACF_CALLBACK* set_visible)(struct _acf_browser_t* self, int visible);

  ///
  /// Get visibility
  ///
  int(ACF_CALLBACK* get_visible)(struct _acf_browser_t* self);

  ///
  /// Get profile object, maybe null
  ///
  struct _acf_profile_t*(ACF_CALLBACK* get_profile)(
      struct _acf_browser_t* self);

  ///
  /// Returns the number of frames that currently exist.
  ///
  size_t(ACF_CALLBACK* get_frame_count)(struct _acf_browser_t* self);

  ///
  /// Returns the identifiers of all existing frames.
  ///
  void(ACF_CALLBACK* get_frame_identifiers)(struct _acf_browser_t* self,
                                            size_t* identifiersCount,
                                            int64* identifiers);

  ///
  /// Returns the names of all existing frames.
  ///
  void(ACF_CALLBACK* get_frame_names)(struct _acf_browser_t* self,
                                      acf_string_list_t names);

  ///
  /// Returns the frame with the specified identifier, or NULL if not found.
  ///
  struct _acf_frame_t*(ACF_CALLBACK* get_frame_byident)(
      struct _acf_browser_t* self,
      int64 identifier);

  ///
  /// Returns the frame with the specified name, or NULL if not found.
  ///
  struct _acf_frame_t*(ACF_CALLBACK* get_frame)(struct _acf_browser_t* self,
                                                const acf_string_t* name);

  ///
  /// Returns the main (top-level) frame for the browser. In the browser process
  /// this will return a valid object until after
  /// CefLifeSpanHandler::OnBeforeClose is called. In the renderer process this
  /// will return NULL if the main frame is hosted in a different renderer
  /// process (e.g. for cross-origin sub-frames). The main frame object will
  /// change during cross-origin navigation or re-navigation after renderer
  /// process termination (due to crashes, etc).
  ///
  struct _acf_frame_t*(ACF_CALLBACK* get_main_frame)(
      struct _acf_browser_t* self);

  ///
  /// Send a key event to the browser.
  ///
  void(ACF_CALLBACK* send_key_event)(struct _acf_browser_t* self,
                                     const acf_key_event_t* event);

  ///
  /// Send a mouse click event to the browser. The |x| and |y| coordinates are
  /// relative to the upper-left corner of the view.
  ///
  void(ACF_CALLBACK* send_mouse_click_event)(struct _acf_browser_t* self,
                                             const acf_mouse_event_t* event,
                                             acf_mouse_button_type_t type,
                                             int mouseUp,
                                             int clickCount);

  ///
  /// Send a mouse move event to the browser. The |x| and |y| coordinates are
  /// relative to the upper-left corner of the view.
  ///
  void(ACF_CALLBACK* send_mouse_move_event)(struct _acf_browser_t* self,
                                            const acf_mouse_event_t* event,
                                            int mouseLeave);

  ///
  /// Send a mouse wheel event to the browser. The |x| and |y| coordinates are
  /// relative to the upper-left corner of the view. The |deltaX| and |deltaY|
  /// values represent the movement delta in the X and Y directions
  /// respectively. In order to scroll inside select popups with window
  /// rendering disabled CefRenderHandler::GetScreenPoint should be implemented
  /// properly.
  ///
  void(ACF_CALLBACK* send_mouse_wheel_event)(struct _acf_browser_t* self,
                                             const acf_mouse_event_t* event,
                                             int deltaX,
                                             int deltaY);

  ///
  /// Set audio mute state
  ///
  void(ACF_CALLBACK* set_audio_muted)(struct _acf_browser_t* self, int muted);

  ///
  /// Get audio mute state
  ///
  int(ACF_CALLBACK* is_audio_muted)(struct _acf_browser_t* self);

  ///
  /// Toggle devtools
  ///
  void(ACF_CALLBACK* toggle_devtools)(struct _acf_browser_t* self);

  ///
  /// Open a browser task manager
  ///
  void(ACF_CALLBACK* open_task_manager)(struct _acf_browser_t* self);

  ///
  /// Raise find bar
  ///
  void(ACF_CALLBACK* raise_find_bar)(struct _acf_browser_t* self);

  ///
  /// Zoom page in current browser
  ///
  void(ACF_CALLBACK* zoom_page)(struct _acf_browser_t* self,
                                acf_zoom_type_t zoom_type);
} acf_browser_t;

///
/// New Window delegate, set a new browser to host target page. Request will be
/// handled while object was destroyed without handled.
///
typedef struct _acf_new_window_delegate_t {
  ///
  /// Base structure.
  ///
  acf_base_ref_counted_t base;

  ///
  /// Set a browser to handle the new window new browser's profile must suit the
  /// host browser's profile, otherwise return false (0).
  ///
  int(ACF_CALLBACK* set_new_browser)(struct _acf_new_window_delegate_t* self,
                                     struct _acf_browser_t* browser);

  ///
  /// Get target url
  ///
  // The resulting string must be freed by calling acf_string_userfree_free().
  acf_string_userfree_t(ACF_CALLBACK* get_target_url)(
      struct _acf_new_window_delegate_t* self);

  ///
  /// Put if user has been handled the request. This function will send the
  /// final request to browser.
  ///
  void(ACF_CALLBACK* handle_request)(struct _acf_new_window_delegate_t* self,
                                     int handled);
} acf_new_window_delegate_t;

///
/// Network auth callback delegate
///
typedef struct _acf_login_delegate_t {
  ///
  /// Base structure.
  ///
  acf_base_ref_counted_t base;

  ///
  /// Continue with username and password
  ///
  void(ACF_CALLBACK* cont)(struct _acf_login_delegate_t* self,
                           const acf_string_t* user_name,
                           const acf_string_t* password);

  ///
  /// Cancel auth request (Default process)
  ///
  void(ACF_CALLBACK* cancel)(struct _acf_login_delegate_t* self);
} acf_login_delegate_t;

///
/// Context menu callback
///
typedef struct _acf_context_menu_callback_t {
  ///
  /// Base structure.
  ///
  acf_base_ref_counted_t base;

  ///
  /// Continue show menu
  ///
  void(ACF_CALLBACK* cont)(struct _acf_context_menu_callback_t* self,
                           int suppress);
} acf_context_menu_callback_t;

#ifdef __cplusplus
}
#endif

#endif  // ACF_INCLUDE_CAPI_ACF_BROWSER_CAPI_H_
